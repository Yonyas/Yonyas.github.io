{"componentChunkName":"component---src-templates-blog-post-js","path":"/TypeScript/[Effective TS] item 18/","result":{"data":{"site":{"siteMetadata":{"title":"Yonyas 블로그","author":"Jiyon Lee","siteUrl":"https://yonyas.github.io","comment":{"disqusShortName":"","utterances":"Yonyas/blog-comments"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"b5b647e0-58ee-5bdf-9a88-5bebc6676964","excerpt":"이펙티브 타입스크립트 아이템 18 부분을 읽으면서 정리한 내용입니다. 불필요한 렌더링을 막기 위해 필요할 때만 차트를 다시 그릴 것이다. 아래 props중 onClick 이벤트를 제외하고만 다시 그리면 된다. 최적화를 두가지 방법으로 구현해 보겠다. (두가지 방법 모두 이상적이지 않은 방법이다) 1. 첫번째 방법 : 보수적 접근법, 실패에 닫힌 접근법 만약 zs, zRange 가 추가된다면 아래 두 조건문을 모두 통과하기 때문에(onClick이 아니니까) 계속 재렌더링이 일어날 것이다.…","html":"<blockquote>\n<p>이펙티브 타입스크립트 아이템 18 부분을 읽으면서 정리한 내용입니다.</p>\n</blockquote>\n<br />\n산점도(scatter plot)을 그리기 위해 UI컴포넌트를 작성한다고 해보자.\n<p>불필요한 렌더링을 막기 위해 필요할 때만 차트를 다시 그릴 것이다. 아래 props중 onClick 이벤트를 제외하고만 다시 그리면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">ScatterProps</span> <span class=\"token punctuation\">{</span>\n  xs<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  ys<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  xRange<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  yRange<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  color<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Events</span>\n  <span class=\"token function-variable function\">onClick</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> index<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>최적화를 두가지 방법으로 구현해 보겠다. (두가지 방법 모두 이상적이지 않은 방법이다)</p>\n<h3 id=\"1-첫번째-방법--보수적-접근법-실패에-닫힌-접근법\" style=\"position:relative;\"><a href=\"#1-%EC%B2%AB%EB%B2%88%EC%A7%B8-%EB%B0%A9%EB%B2%95--%EB%B3%B4%EC%88%98%EC%A0%81-%EC%A0%91%EA%B7%BC%EB%B2%95-%EC%8B%A4%ED%8C%A8%EC%97%90-%EB%8B%AB%ED%9E%8C-%EC%A0%91%EA%B7%BC%EB%B2%95\" aria-label=\"1 첫번째 방법  보수적 접근법 실패에 닫힌 접근법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 첫번째 방법 : 보수적 접근법, 실패에 닫힌 접근법</h3>\n<ul>\n<li>만약 zs, zRange 가 추가된다면 아래 두 조건문을 모두 통과하기 때문에(onClick이 아니니까) 계속 재렌더링이 일어날 것이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">shouldUpdate</span><span class=\"token punctuation\">(</span>oldProps<span class=\"token operator\">:</span> ScatterProps<span class=\"token punctuation\">,</span> newProps<span class=\"token operator\">:</span> ScatterProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> k<span class=\"token operator\">:</span> <span class=\"token keyword\">keyof</span> ScatterProps<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>k <span class=\"token keyword\">in</span> oldProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldProps<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> newProps<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">!==</span> <span class=\"token string\">'onClick'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"2-두번째-방법--실패에-열린-접근법\" style=\"position:relative;\"><a href=\"#2-%EB%91%90%EB%B2%88%EC%A7%B8-%EB%B0%A9%EB%B2%95--%EC%8B%A4%ED%8C%A8%EC%97%90-%EC%97%B4%EB%A6%B0-%EC%A0%91%EA%B7%BC%EB%B2%95\" aria-label=\"2 두번째 방법  실패에 열린 접근법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 두번째 방법 : 실패에 열린 접근법</h3>\n<ul>\n<li>zs나 zRange가 추가되어도 <code class=\"language-text\">false</code> 기 때문에 재렌더는 일어나지 않는다. 그러나 이 역시 좋은 방법은 아닌데 그 이유는 zs나 zRagne 가 추가될 때마다 누락하지 않고 입력해줘야 하는데 놓칠 수도 있기 때문이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">shouldUpdate</span><span class=\"token punctuation\">(</span>oldProps<span class=\"token operator\">:</span> ScatterProps<span class=\"token punctuation\">,</span> newProps<span class=\"token operator\">:</span> ScatterProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    oldProps<span class=\"token punctuation\">.</span>xs <span class=\"token operator\">!==</span> newProps<span class=\"token punctuation\">.</span>xs <span class=\"token operator\">||</span>\n    oldProps<span class=\"token punctuation\">.</span>ys <span class=\"token operator\">!==</span> newProps<span class=\"token punctuation\">.</span>ys <span class=\"token operator\">||</span>\n    oldProps<span class=\"token punctuation\">.</span>xRange <span class=\"token operator\">!==</span> newProps<span class=\"token punctuation\">.</span>xRange <span class=\"token operator\">||</span>\n    oldProps<span class=\"token punctuation\">.</span>yRange <span class=\"token operator\">!==</span> newProps<span class=\"token punctuation\">.</span>yRange <span class=\"token operator\">||</span>\n    oldProps<span class=\"token punctuation\">.</span>color <span class=\"token operator\">!==</span> newProps<span class=\"token punctuation\">.</span>color\n    <span class=\"token comment\">// (no check for onClick)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"이상적인-방법은-\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%83%81%EC%A0%81%EC%9D%B8-%EB%B0%A9%EB%B2%95%EC%9D%80-\" aria-label=\"이상적인 방법은  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이상적인 방법은 ??</h2>\n<p>새로운 속성이 추가될 때마다 사용자가 직접 shouldUpdate를 고치도록 하는게 좋다.</p>\n<p>바로바로 매핑된 타입과 객체를 사용하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token constant\">REQUIRES_UPDATE</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>k <span class=\"token keyword\">in</span> <span class=\"token keyword\">keyof</span> ScatterProps<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 여기 scatterProps</span>\n  xs<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  ys<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  xRange<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  yRange<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  color<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  onClick<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">shouldUpdate</span><span class=\"token punctuation\">(</span>oldProps<span class=\"token operator\">:</span> ScatterProps<span class=\"token punctuation\">,</span> newProps<span class=\"token operator\">:</span> ScatterProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 여기 scatterProps</span>\n  <span class=\"token keyword\">let</span> k<span class=\"token operator\">:</span> <span class=\"token keyword\">keyof</span> ScatterProps<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>k <span class=\"token keyword\">in</span> oldProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldProps<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> newProps<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token constant\">REQUIRES_UPDATE</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>체크한 두 곳을 보면 같은 타입을 공유하고 있기 때문에 하나를 변경하면 다른 하나도 변경해야 함을 알 수 있다.</li>\n<li>매핑된 타입은 한 객체가 또 다른 객체와 정확히 같은 속성을 가지게 할 때 이상적이다.</li>\n</ul>","frontmatter":{"title":"[Book] 이펙티브 타입스크립트 : 매핑된 타입을 사용하여 값을 동기화하기","date":"May 02, 2022"}}},"pageContext":{"slug":"/TypeScript/[Effective TS] item 18/","previous":{"fields":{"slug":"/TypeScript/[Effective TS] item 15/"},"frontmatter":{"title":"[Book] 이펙티브 타입스크립트 : 동적 데이터에 인덱스 시그니처 사용하기"}},"next":null}},"staticQueryHashes":["2486386679","3128451518"]}